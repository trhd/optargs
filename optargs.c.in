/**
 * optargs -- A command line option and argument management library.
 * Copyright (C) 2016-2018 Hemmo Nieminen
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <assert.h>
#include <ctype.h>
#include <errno.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "optargs.h"

#mesondefine WARN_OPTIONS_AS_ARGUMENTS

WARN_UNUSED_RESULT
static int parse_arguments(int const ac, char const * NONNULL const * NONNULL const av, struct optargs_argument * NONNULL args);

enum constants
{
	MAX_WIDTH = 79,
	LEFT_COLUMN_MAX_WIDTH = 38
};

WARN_UNUSED_RESULT
static int
max(const int a, const int b)
{
	return a > b ? a : b;
}

WARN_UNUSED_RESULT
static int
min(const int a, const int b)
{
	return a > b ? b : a;
}

WARN_UNUSED_RESULT
static int
word_length(char const * NONNULL s)
{
	assert(s);

	return strcspn(s, " =\t\v\n\r\0");
}

static void
strcpyup(char * NONNULL dst, char const * NONNULL src, unsigned int len)
{
	assert(dst);
	assert(src);
	assert(len);

	for (unsigned int i = 0 ; i < len ; i++)
		dst[i] = toupper(src[i]);
}

WARN_UNUSED_RESULT
static bool
is_word_separator(char const c)
{
	return c == ' ' || c == '\t' || c == '\v' || c == '\n' || c == '\r' || c == '\0';
}

WARN_UNUSED_RESULT
static bool
argument_is_eol(struct optargs_argument const * NONNULL const arg)
{
	return arg->type == _optargs_argument_eol || arg->type == _optargs_argument_sink;
}

WARN_UNUSED_RESULT
static bool
option_is_valid(struct optargs_option const * NONNULL const o)
{
	assert(o);

	if (o->value_type == optargs_flag)
		return true;
	else if (!o->argument)
		return true;
	else
		return !argument_is_eol(o->argument);
}

WARN_UNUSED_RESULT
static bool
option_supports_argument(struct optargs_option const * NONNULL o)
{
	assert(o);

	return o->value_type != optargs_flag && o->argument;
}

WARN_UNUSED_RESULT
static int
opt_missing_arg_error(struct optargs_option const * NONNULL const opt)
{
	assert(opt);

	char buf[5] = "'-";

	fprintf(stderr, "Mandatory argument for option %s%s%s%s%s missing.\n",
			opt->long_option ? "'--" : "", opt->long_option ? opt->long_option : "", opt->long_option ? "'" : "",
			opt->long_option && opt->short_option ? " / " : "",
			opt->short_option ? strcat(strncat(buf, &opt->short_option, 1), "'") : "");

	return -EINVAL;
}

WARN_UNUSED_RESULT
static int
non_wanted_argument_error(struct optargs_option const * NONNULL const opt)
{
	assert(opt);

	char buf[5] = "'-";

	fprintf(stderr, "The option %s%s%s%s%s doesn't take an argument.\n",
			opt->long_option ? "'--" : "", opt->long_option ? opt->long_option : "", opt->long_option ? "'" : "",
			opt->long_option && opt->short_option ? " / " : "",
			opt->short_option ? strcat(strncat(buf, &opt->short_option, 1), "'") : "");

	return -EINVAL;
}

WARN_UNUSED_RESULT
static int
redefine_option_argument_error(struct optargs_option const * NONNULL const opt)
{
	assert(opt);

	char buf[5] = "'-";

	fprintf(stderr, "Conflicting arguments given for the option %s%s%s%s%s.\n",
			opt->long_option ? "'--" : "", opt->long_option ? opt->long_option : "", opt->long_option ? "'" : "",
			opt->long_option && opt->short_option ? " / " : "",
			opt->short_option ? strcat(strncat(buf, &opt->short_option, 1), "'") : "");

	return -EINVAL;
}

#if WARN_OPTIONS_AS_ARGUMENTS

WARN_UNUSED_RESULT
static bool
looks_like_an_option(char const * NONNULL arg)
{
	assert(arg);

	return arg[0] == '-';
}

static void
option_as_argument_warning(struct optargs_option const * NONNULL opt, char const * NONNULL arg)
{
	char buf[5] = "'-";

	fprintf(stderr, "WARNING: The argument '%s' for option %s%s%s%s%s looks like it could\n         have been meant as an option.\n",
			arg,
			opt->long_option ? "'--" : "", opt->long_option ? opt->long_option : "", opt->long_option ? "'" : "",
			opt->long_option && opt->short_option ? " / " : "",
			opt->short_option ? strcat(strncat(buf, &opt->short_option, 1), "'") : "");
}

#endif

WARN_UNUSED_RESULT
static int
unmatching_optional_argument_error(char const * NONNULL const opt, char const * NONNULL const hdr)
{
	assert(opt);
	assert(hdr);

	int len = strlen(hdr);
	char buf[len];

	strcpyup(buf, hdr, len);
	buf[len] = '\0';

	fprintf(stderr, "'%s' is not a valid value for optional argument '%s'.\n",
			opt, buf);
	return -EINVAL;
}

WARN_UNUSED_RESULT
static int
unmatching_mandatory_argument_error(char const * NONNULL const opt, char const * NONNULL const hdr)
{
	assert(opt);
	assert(hdr);

	int len = strlen(hdr);
	char buf[len];

	strcpyup(buf, hdr, len);
	buf[len] = '\0';

	fprintf(stderr, "'%s' is not a valid value for mandatory argument '%s'.\n",
			opt, buf);
	return -EINVAL;
}

WARN_UNUSED_RESULT
static bool
starts_with_single_hyphen(char const * NONNULL const str)
{
	assert(str);

	return str[0] == '-';
}

WARN_UNUSED_RESULT
static bool
starts_with_double_hyphen(char const * NONNULL const opt)
{
	assert(opt);
	assert(starts_with_single_hyphen(opt));

	return opt[1] == '-';
}

WARN_UNUSED_RESULT
static bool
is_empty_argument(char const * NONNULL const str)
{
	assert(str);

	return *str == '\0';
}

WARN_UNUSED_RESULT
static bool
is_double_hyphen(char const * NONNULL const opt)
{
	assert(opt);

	return opt[0] == '-' && opt[1] == '-' && opt[2] == '\0';
}

WARN_UNUSED_RESULT
static int
long_option_is_invalid(char const * NONNULL o, int const l)
{
	assert(o);
	assert(l > 0);

	fprintf(stderr, "Unrecognized long option '%.*s'.\n", l, o);

	return -EINVAL;
}

WARN_UNUSED_RESULT
static int
short_option_is_invalid(char const c)
{
	fprintf(stderr, "Unrecognized short option '%c'.\n", c);

	return -EINVAL;
}

WARN_UNUSED_RESULT
static bool
option_is_divider(struct optargs_option const * NONNULL const opt)
{
	assert(opt);

	return !(opt->short_option || opt->long_option);
}

WARN_UNUSED_RESULT
static bool
option_is_hidden(struct optargs_option const * NONNULL const opt)
{
	assert(opt);

	return !option_is_divider(opt) && !opt->description;
}

WARN_UNUSED_RESULT
static bool
argument_is_header(struct optargs_argument const * NONNULL const arg)
{
	assert(arg);

	return (arg->type == optargs_argument_group || arg->type == optargs_argument_group_opt);
}

WARN_UNUSED_RESULT
static bool
argument_is_divider(struct optargs_argument const * NONNULL const arg)
{
	assert(arg);

	return arg->type == _optargs_argument_divider;
}

WARN_UNUSED_RESULT
static bool
argument_type_is_any(struct optargs_argument const * NONNULL const arg)
{
	assert(arg);

	return arg->type == optargs_argument_any || arg->type == optargs_argument_any_opt;
}

WARN_UNUSED_RESULT
static struct optargs_option *
locate_short_option(struct optargs_option * NONNULL o, char const c)
{
	assert(o);

	for ( ; option_is_valid(o) ; o++)
		if (o->short_option == c)
			return o;

	return NULL;
}

static void
locate_long_option(struct optargs_option * NONNULL* NONNULL o, char const * NONNULL l, int const ll)
{
	assert(o);
	assert(*o);
	assert(l);
	assert(ll > 0);

	for ( ; option_is_valid(*o) ; (*o)++)
	{
		if (!(*o)->long_option)
			continue;

		if ((int)strlen((*o)->long_option) != ll)
			continue;

		if ((*o)->long_option && !strncmp((*o)->long_option, l, ll))
			break;
	}
}

static void
mark_default_option(struct optargs_option * NONNULL opt)
{
	assert(opt);

	if (opt->value_type == optargs_flag)
		opt->count++;
	else
	{
		opt->value_type = optargs_flag;
		opt->count = 1;
	}
}

WARN_UNUSED_RESULT
static int
mark_no_argument_option(struct optargs_option * NONNULL opt, bool const assign)
{
	assert(opt);

	if (assign)
		return non_wanted_argument_error(opt);

	mark_default_option(opt);

	return 0;
}

WARN_UNUSED_RESULT
static int
mark_argument_option(struct optargs_option * NONNULL opt, char const * NONNULL const arg)
{
	if (opt->value_type)
		return redefine_option_argument_error(opt);

	if (!arg)
		return opt_missing_arg_error(opt);

	opt->value_type = optargs_argument;
	if (parse_arguments(1, &arg, opt->argument) < 0)
		return -1;

#if WARN_OPTIONS_AS_ARGUMENTS
	if (looks_like_an_option(arg))
		option_as_argument_warning(opt, arg);
#endif

	return 1;
}

WARN_UNUSED_RESULT
static int
mark_optional_argument_option(struct optargs_option * NONNULL opt,
		char const * NONNULL const arg, bool const assign)
{
	assert(opt);

	if (assign && arg)
		return mark_argument_option(opt, arg);

	if (opt->value_type)
		return redefine_option_argument_error(opt);

	mark_default_option(opt);

	return 0;
}

WARN_UNUSED_RESULT
static int
mark_option(struct optargs_option * NONNULL opt, char const * NONNULL const arg, bool const force)
{
	assert(opt);

	if (!option_supports_argument(opt))
		return mark_no_argument_option(opt, force);

	switch (opt->argument->type)
	{
		case optargs_argument_any:
		case optargs_argument_group:
			return mark_argument_option(opt, arg);
		case _optargs_argument_eol:
		case _optargs_argument_sink:
		case _optargs_argument_divider:
		case optargs_argument_any_opt:
		case optargs_argument_group_opt:
			return mark_optional_argument_option(opt, arg, force);
		case optargs_argument_group_member:
			break;
	}
	abort();
}

WARN_UNUSED_RESULT
static int
parse_short_option(char const * NONNULL c, char const * NONNULL n, struct optargs_option * NONNULL const o)
{
	assert(c);
	assert(o);
	assert(starts_with_single_hyphen(c));

	struct optargs_option * t;
	int r;

	if (*++c == '\0')
		return short_option_is_invalid(*c);

	for (r = 0 ; r == 0 && *c != '\0'; c++)
	{
		t = locate_short_option(o, *c);

		if (!t)
			r = short_option_is_invalid(*c);
		else if (c[1] == '=')
			r = mark_option(t, c + 2, true);
		else if (c[1] != '\0')
			r = mark_option(t, c + 1, false);
		else
		{
			r = mark_option(t, n, false);
			if (r >= 0)
				r++;
		}
	}

	return r;
}

WARN_UNUSED_RESULT
static int
parse_long_option(char const * NONNULL c, char const * NONNULL n, struct optargs_option * NONNULL o)
{
	assert(c);
	assert(o);

	int r, d;

	assert(c[0] == '-' && c[1] == '-');
	c += 2;
	d = word_length(c);

	locate_long_option(&o, c, d);

	if (!option_is_valid(o))
		r = long_option_is_invalid(c, d);
	else if (c[d] == '=')
		r = mark_option(o, &c[d + 1], true);
	else if ((r = mark_option(o, n, false)) >= 0)
		r++;

	return r;
}

#if !defined(NDEBUG) || defined(UNIT_TESTING)

/**
 * Ensure all the required fields are filled for any given type of an
 * argument.
 */
static void
assert_argument_required_fields(struct optargs_argument const * NONNULL const arg)
{
	switch (arg->type)
	{
		case optargs_argument_any:
		case optargs_argument_any_opt:
		case optargs_argument_group_member:
			assert(arg->name);
			assert(arg->description);
			break;
		case optargs_argument_group:
		case optargs_argument_group_opt:
			assert(arg->name);
			break;
		case _optargs_argument_divider:
			assert(!arg->description);
			break;
		default:
			break;
	}
}

/**
 * Ensure all the required fields are filled for any given type of an
 * option argument.
 */
static void
assert_option_argument_required_fields(struct optargs_argument const * NONNULL const arg)
{
	switch (arg->type)
	{
		case optargs_argument_any:
		case optargs_argument_any_opt:
		case optargs_argument_group_member:
			assert(arg->name);
			break;
		case optargs_argument_group:
		case optargs_argument_group_opt:
			assert(arg->name);
			break;
		case _optargs_argument_divider:
			assert(!arg->description);
			break;
		default:
			break;
	}
}

/**
 * All optinal arguments should be at the and of the expected arguments' list
 */
static void
assert_optional_arguments_at_the_end(struct optargs_argument const * NONNULL args)
{
	assert(args);

	for (bool f = false ; !argument_is_eol(args) ; args++)
	{
		if (args->type == _optargs_argument_divider
				|| args->type == optargs_argument_group_member)
			continue;

		assert(!f || args->type == optargs_argument_any_opt || args->type == optargs_argument_group_opt);

		if (args->type == optargs_argument_any_opt || args->type == optargs_argument_group_opt)
			f = true;
	}
}

/**
 * Only optargs_argument_group_member type arguments should use subarguments.
 */
static void
assert_subargument_sanity(struct optargs_argument const * NONNULL args)
{
	assert(args);

	for ( ; !argument_is_eol(args) ; args++)
	{
		if (args->subargument)
		{
			assert(args->type == optargs_argument_group_member);
			assert_subargument_sanity(args->subargument);
		}
	}
}

static void
assert_argument_sanity(struct optargs_argument const * NONNULL args)
{
	assert(args);

	assert_optional_arguments_at_the_end(args);

	if (args->type == optargs_argument_group || args->type == optargs_argument_group_opt)
		assert(!args->subargument);
	else
		assert_subargument_sanity(args);

	for ( ; !argument_is_eol(args) ; args++)
		assert_argument_required_fields(args);
}

static void
assert_option_sanity(struct optargs_option const * NONNULL opts)
{
	assert(opts);

	for ( ; option_is_valid(opts) ; opts++)
	{
		if (option_supports_argument(opts))
		{
			struct optargs_argument const * arg = opts->argument;
			assert(arg);

			assert_option_argument_required_fields(arg);
			assert_optional_arguments_at_the_end(arg);

			for ( ; !argument_is_eol(arg) ; arg++ )
				assert(!arg->subargument);
			assert(arg->type != _optargs_argument_sink);
		}
	}
}

#else

# define assert_optional_arguments_at_the_end(...)
# define assert_argument_sanity(...)
# define assert_option_sanity(...)

#endif

int
optargs_parse_options(int const ac, char const * NONNULL const * NONNULL const av, struct optargs_option * NONNULL const opts)
{
	assert(ac > 0);
	assert(av);
	assert(opts);
	assert_option_sanity(opts);

	int i, j;
	char const *o, *n;

	for (i = 1; i < ac; i += j)
	{
		o = av[i];
		assert(o);
		n = i < ac - 1 ? av[i + 1] : NULL;

		if (is_empty_argument(o))
		{
			j = 1;
			continue;
		}

		if (!starts_with_single_hyphen(o))
			return i;

		if (!starts_with_double_hyphen(o))
			j = parse_short_option(o, n, opts);
		else if (is_double_hyphen(o))
			return i + 1;
		else
			j = parse_long_option(o, n, opts);

		if (j < 0)
			return j;
	}

	return i;
}

WARN_UNUSED_RESULT
static int
argument_name_compare(const char * NONNULL a, const char * NONNULL b)
{
	assert(a);
	assert(b);

	int al = word_length(a),
	    bl = word_length(b);

	if (al > bl)
		return -1;
	else if (bl > al)
		return 1;
	else
		return strncmp(a, b, min(al, bl));
}

WARN_UNUSED_RESULT
static int
invalid_argument_for_group(char const * NONNULL arg, struct optargs_argument const * NONNULL grp)
{
	assert(arg);
	assert(grp);

	if (grp->type == optargs_argument_group)
		return unmatching_mandatory_argument_error(arg, grp->name);
	else
		return unmatching_optional_argument_error(arg, grp->name);
}

WARN_UNUSED_RESULT
static int
missing_argument_error(char const * NONNULL a)
{
	assert(a);

	int len = strlen(a);
	char buf[len];

	strcpyup(buf, a, len);
	buf[len] = '\0';

	fprintf(stderr, "Missing an argument for '%s'.\n", buf);

	return -EINVAL;
}

WARN_UNUSED_RESULT
static int
check_for_missing_mandatory_arguments(struct optargs_argument const * NONNULL args)
{
	for ( ; !argument_is_eol(args) ; args++)
	{
		if (args->type == optargs_argument_group
				|| args->type == optargs_argument_any)
			return missing_argument_error(args->name);
	}

	return 0;
}

WARN_UNUSED_RESULT
static int
excess_arguments_error(int g, int e)
{
	assert(g > 0);
	assert(e >= 0);

	fprintf(stderr, "Too many arguments; got %d and expected at most %d.\n", g, e);

	return -EINVAL;
}


WARN_UNUSED_RESULT
static int
parse_arguments(int const ac, char const * NONNULL const * NONNULL const av, struct optargs_argument * NONNULL args)
{
	assert(ac >= 0);
	assert(!ac || av);
	assert(args);

	struct optargs_argument * grp = NULL;
	int i, t;

	for (i = 0 ; !argument_is_eol(args) && i < ac ; args++)
	{
		if (args->type == _optargs_argument_divider)
		{}
		else if (grp)
		{
			if (args->type != optargs_argument_group_member)
				return invalid_argument_for_group(av[i], grp);

			if (!argument_name_compare(args->name, av[i]))
			{
				args->result.value = av[i];
				grp->result.match = args;
				grp = NULL;
				i++;
				if (args->subargument)
				{
					t = parse_arguments(ac - i, av + i, args->subargument);

					if (t < 0)
						return t;
					else
						i += t;
				}
			}
		}
		else if (args->type == optargs_argument_group_member)
		{}
		else if (args->type == optargs_argument_group
				|| args->type == optargs_argument_group_opt)
			grp = args;
		else
		{
			assert(args->type == optargs_argument_any || args->type == optargs_argument_any_opt);
			args->result.value = av[i];
			i++;
		}
	}

	if (grp)
	{
		assert(i < ac);
		return invalid_argument_for_group(av[i], grp);
	}

	if (i < ac && args->type != _optargs_argument_sink)
		return excess_arguments_error(ac, i);

	t = check_for_missing_mandatory_arguments(args);

	return t < 0 ? t : i;
}

WARN_UNUSED_RESULT
int
optargs_parse_arguments(int const ac, char const * NONNULL const * NONNULL const av, struct optargs_argument * NONNULL args)
{
	assert(ac >= 0);
	assert(!ac || av);
	assert(args);
	assert_argument_sanity(args);

	return parse_arguments(ac, av, args);
}

static void
close_optionality_brackets(int * NONNULL l)
{
	assert(l);

	for ( ; *l ; --*l)
		printf("]");
}

WARN_UNUSED_RESULT
static int print_subargument(struct optargs_argument const * NONNULL args, int * NONNULL l);

WARN_UNUSED_RESULT
static int
print_group_names(struct optargs_argument const * NONNULL args)
{
	assert(args);

	int rv, l;

	for ( rv = 0, l = 0 ; args->type == optargs_argument_group_member ; args++)
	{
		printf("%s %s", !rv ? "" : " |", args->name);
		rv += strlen(args->name) + (!rv ? 1 : 3);
		if (args->subargument)
			rv += print_subargument(args->subargument, &l);
	}

	return rv;
}

WARN_UNUSED_RESULT
static int
print_arg_group(struct optargs_argument const * NONNULL const arg, char const * NONNULL const prefix)
{
	assert(arg);
	assert(prefix);

	int rv = 0;

	printf("%s{", prefix);
	rv = print_group_names(arg + 1) + 3 + strlen(prefix);
	printf(" }");

	return rv;
}

WARN_UNUSED_RESULT
static int
print_arg_group_name(struct optargs_argument const * NONNULL const arg, char const * NONNULL const prefix)
{
	assert(arg);
	assert(prefix);

	int l = word_length(arg->name);
	char buf[l + 1];

	strcpyup(buf, arg->name, l);
	buf[l] = '\0';

	printf("%s%s", prefix, buf);

	return l + strlen(prefix);
}

WARN_UNUSED_RESULT
static int
print_arg_any_name(struct optargs_argument const * NONNULL const arg, char const * NONNULL const prefix)
{
	assert(arg);
	assert(arg->name);
	assert(prefix);

	int l = word_length(arg->name);

	printf("%s%.*s", prefix, l, arg->name);

	return l + strlen(prefix);
}

static int
print_arg_name(struct optargs_argument const * NONNULL const arg, int * NONNULL l)
{
	assert(arg);

	int rv = 0;

	switch (arg->type)
	{
		case optargs_argument_group:
			if (!arg->name)
				rv += print_arg_group(arg, " ");
			else
				rv += print_arg_group_name(arg, " ");
			break;
		case optargs_argument_any:
			rv += print_arg_any_name(arg, " ");
			break;
		case optargs_argument_group_opt:
			++*l;
			if (!arg->name)
				rv += print_arg_group(arg, " [");
			else
				rv += print_arg_group_name(arg, " [");
			rv += 1;
			break;
		case optargs_argument_any_opt:
			++*l;
			rv += print_arg_any_name(arg, " [");
			rv += 1;
			break;
		case optargs_argument_group_member:
		case _optargs_argument_divider:
			break;
		case _optargs_argument_eol:
		case _optargs_argument_sink:
			abort();
	}

	return rv;
}

static void
print_arg_names(struct optargs_argument const * NONNULL args)
{
	assert(args);

	int l = 0;

	for ( ; !argument_is_eol(args) ; args++)
		print_arg_name(args, &l);

	close_optionality_brackets(&l);
}

WARN_UNUSED_RESULT
static int
calc_line_length(char const * NONNULL const src, int const cols)
{
	assert(src);
	assert(cols > 0);

	int r, t;

	for (r = 0, t = 0 ; r < cols && src[r] != '\n' && src[r] != '\0' ; r++)
	{
		if (is_word_separator(src[r]))
			t = r;
	}

	if (!is_word_separator(src[r]))
	{
		if (t)
			r = t;
		else
			while (!is_word_separator(src[++r]));
	}

	return r;
}

static void
print_wrapped(char const * NONNULL src, int width, int const indent)
{
	assert(src);
	assert(width > 0);
	assert(*src != '\0');

	bool first = true;

	width -= indent;

	do {
		int l = calc_line_length(src, width);
		printf("%*s%.*s\n", first ? 0 : indent, "", l, src);
		first = false;
		src += l + 1;
	} while (*(src - 1) != '\0');
}

WARN_UNUSED_RESULT
static int
get_option_argument_length(struct optargs_argument const * NONNULL arg)
{
	assert(arg);

	int i = 0, j, e;

	if (arg->type == optargs_argument_any_opt || arg->type == optargs_argument_group_opt)
		e = 2;
	else
		e = 0;

	for ( ; !argument_is_eol(arg) ; arg++)
	{
		if (!arg->name)
			continue;

		j = strlen(arg->name);

		if (i < j)
			i = j;
	}

	return i + e + 1;
}

WARN_UNUSED_RESULT
static int
get_opt_length(struct optargs_option const * NONNULL const opt)
{
	assert(opt);

	int r = 0;

	if (opt->long_option)
	{
		r += strlen(opt->long_option) + 2;

		if (opt->short_option)
			r += 3;
	}
	else if (opt->short_option)
		r += 2;

	if (option_supports_argument(opt))
		r += get_option_argument_length(opt->argument);

	return r;
}


WARN_UNUSED_RESULT
static int
find_longest_opt(struct optargs_option const * NONNULL opts)
{
	assert(opts);

	int r, t;

	for (r = 0 ; option_is_valid(opts) ; opts++)
	{
		if (option_is_hidden(opts))
			continue;

		if (option_is_divider(opts))
			continue;

		t = get_opt_length(opts);

		if (t > LEFT_COLUMN_MAX_WIDTH)
			continue;

		r = max(r, t);
	}

	return r;
}

WARN_UNUSED_RESULT
static int
get_arg_length(struct optargs_argument const * NONNULL const arg)
{
	assert(arg);

	int l = arg->name ? strlen(arg->name) : 0;

	/* Headers will get a ':' character appended to them. */
	if (arg->type == optargs_argument_group
			|| arg->type == optargs_argument_group_opt)
		++l;

	return l;
}

WARN_UNUSED_RESULT
static int
find_longest_arg(struct optargs_argument const * NONNULL args)
{
	assert(args);

	int r;

	for (r = 0; !argument_is_eol(args) ; args++)
	{
		int t = get_arg_length(args);

		if (args->subargument)
			t += 1 + find_longest_arg(args->subargument);

		if (t > LEFT_COLUMN_MAX_WIDTH)
			continue;

		r = max(r, t);
	}

	return r;
}

WARN_UNUSED_RESULT
static int
find_left_column_maximum(struct optargs_option const * NONNULL const opts,
		struct optargs_argument const * NONNULL const args)
{
	return min(
		LEFT_COLUMN_MAX_WIDTH,
		max(
			opts ? find_longest_opt(opts) : 0,
			args ? find_longest_arg(args) : 0
		) + 3
	);
}

WARN_UNUSED_RESULT
static int
print_option_options(struct optargs_option const * NONNULL const opt)
{
	assert(opt);

	if (opt->short_option && opt->long_option)
	{
		printf("  -%c,--%s", opt->short_option, opt->long_option);
		return 7 + strlen(opt->long_option);
	}

	if (opt->short_option)
	{
		printf("  -%c", opt->short_option);
		return 4;
	}

	assert(opt->long_option);
	printf("  --%s", opt->long_option);
	return strlen(opt->long_option) + 4;
}

WARN_UNUSED_RESULT
static int
print_mandatory_option_argument(struct optargs_option const * NONNULL const opt)
{
	assert(opt);
	assert(opt->argument);
	assert(opt->argument->name);

	int z = word_length(opt->argument->name);
	char buf[z + 1];
	strcpyup(buf, opt->argument->name, z);
	buf[z] = '\0';
	printf(" %.*s", (int)z, buf);
	return z + 1;
}

WARN_UNUSED_RESULT
static int
print_optional_option_argument(struct optargs_option const * NONNULL const opt)
{
	assert(opt);
	assert(opt->argument);
	assert(opt->argument->name);

	int z = word_length(opt->argument->name);
	char buf[z + 1];
	strcpyup(buf, opt->argument->name, z);
	buf[z] = '\0';
	printf("[=%.*s]", z, buf);
	return z + 3;
}

WARN_UNUSED_RESULT
static int
print_option_argument(struct optargs_option const * NONNULL const opt)
{
	assert(opt);

	if (!option_supports_argument(opt))
		return 0;

	switch (opt->argument->type)
	{
		case optargs_argument_any:
		case optargs_argument_group:
			return print_mandatory_option_argument(opt);
		case optargs_argument_any_opt:
		case optargs_argument_group_opt:
			return print_optional_option_argument(opt);
		case _optargs_argument_eol:
		case _optargs_argument_sink:
		case _optargs_argument_divider:
		case optargs_argument_group_member:
			return 0;
	}
	abort();
}

static void
print_option_padding(int const width, int const pos)
{
	if (pos >= width)
		printf("\n%*s", width, "");
	else
		printf("%-*s", width - pos, "");
}

static void
print_option_argument_group(struct optargs_argument const * NONNULL const arg, int left_column)
{
	assert(arg);
	assert(arg->name);
	assert(arg->description);

	int name_length = strlen(arg->name),
	    right_indent = 1;
	char buf[name_length + 1];

	strcpyup(buf, arg->name, name_length);
	buf[name_length] = '\0';

	printf("    %s", buf);

	if (4 + name_length >= left_column)
		printf("\n%*s", left_column + right_indent, "");
	else
		printf("%*s", left_column - 4 - name_length + right_indent, "");

	print_wrapped(arg->description, MAX_WIDTH, left_column + right_indent);
}

static void
print_option_argument_item(struct optargs_argument const * NONNULL const arg, int left_column)
{
	assert(arg);
	assert(arg->name);
	assert(arg->description);

	int name_length = strlen(arg->name),
	    right_indent = 1;

	printf("     %s", arg->name);

	if (4 + name_length >= left_column)
		printf("\n%*s", left_column + right_indent, "");
	else
		printf("%*s", left_column - 4 - name_length + right_indent, "");

	print_wrapped(arg->description, MAX_WIDTH, left_column);
}

static void
print_option_argument_description(struct optargs_argument const * NONNULL arg,
		int const left_column)
{
	assert(arg);

	for ( ; !argument_is_eol(arg) ; arg++)
	{
		if (arg->type == optargs_argument_group_member)
			print_option_argument_item(arg, left_column);
		else if (arg->description)
			print_option_argument_group(arg, left_column);
	}
}

static void
print_regular_option(struct optargs_option const * NONNULL const opt,
		int const left_column)
{
	int len = print_option_options(opt);
	len += print_option_argument(opt);
	print_option_padding(left_column, len);
	print_wrapped(opt->description, MAX_WIDTH, left_column);

	if (option_supports_argument(opt))
		print_option_argument_description(opt->argument, left_column);
}


static void
print_option(struct optargs_option const * NONNULL const opt, int const left_column)
{
	if (option_is_divider(opt))
		printf("\n");
	else if (!option_is_hidden(opt))
		print_regular_option(opt, left_column + 2);
}

WARN_UNUSED_RESULT
static int
count_printable_options(struct optargs_option const * NONNULL opts)
{
	assert(opts);

	int rv;

	for (rv = 0 ; option_is_valid(opts) ; opts++)
		if (!option_is_hidden(opts))
			rv++;

	return rv;
}

static void
print_all_options(struct optargs_option const * NONNULL opts, int const indent)
{
	assert(opts);
	assert(indent > 0);

	if (count_printable_options(opts))
		printf("\nOPTIONS:\n");

	for ( ; option_is_valid(opts) ; ++opts)
		print_option(opts, indent);
}

WARN_UNUSED_RESULT
static int
print_subargument(struct optargs_argument const * NONNULL args, int * NONNULL l)
{
	assert(args);
	assert(l);

	int rv = 0;

	for ( ; !argument_is_eol(args) ; args++)
	{
		rv += print_arg_name(args, l);
		if (args->subargument)
			rv += print_subargument(args->subargument, l);
	}

	close_optionality_brackets(l);

	return rv;
}

static void
print_normal_argument(struct optargs_argument const * NONNULL const arg, int const left_column, int const indent)
{
	assert(arg);
	assert(left_column > 0);
	assert(indent >= 2);

	int length = indent + strlen(arg->name),
		tmp = 0;

	printf("%*s%s", indent, "", arg->name);

	if (arg->subargument)
		length += print_subargument(arg->subargument, &tmp);

	if (length >= left_column + indent)
		printf("\n%*s", left_column + indent, "");
	else
		printf("%*s", left_column - length + indent, "");

	print_wrapped(arg->description, MAX_WIDTH, left_column + indent);

	if (arg->type == optargs_argument_group_member && argument_type_is_any(arg + 1))
		printf("\n");
}

static void
print_argument_header(struct optargs_argument const * NONNULL const arg, int const left_column, int const indent)
{
	assert(arg);
	assert(left_column > 0);
	assert(indent >= 0);

	int name_length = strlen(arg->name),
	    right_indent = indent ? indent : 1;
	char buf[name_length + 1];

	strcpyup(buf, arg->name, name_length);
	buf[name_length] = '\0';

	if (!arg->description)
		printf("%*s%s:\n", indent, "", buf);
	else
	{
		printf("%*s%s:", indent, "", buf);

		if (indent + name_length + 1 >= left_column + right_indent)
			printf("\n%*s", left_column + right_indent, "");
		else
			printf("%*s", left_column - indent - name_length - 1 + right_indent, "");
		print_wrapped(arg->description, MAX_WIDTH, left_column + right_indent);
	}
}

static void
print_all_arguments(struct optargs_argument const * NONNULL args, int const left_column, unsigned int const indent)
{
	assert(args);
	assert(left_column > 0);

	int extra_indent = 0;
	bool group = false;

	if (!indent && !(argument_is_header(args) && args->name))
	{
		printf("\nARGUMENTS:\n");
		extra_indent = 2;
		group = true;
	}

	for ( ; !argument_is_eol(args) ; args++)
	{
		if (argument_is_divider(args))
		{
			printf("\n");
			continue;
		}

		if (!args->name)
		{
			if (argument_is_header(args) && group)
				printf("\n");
			continue;
		}

		if (argument_is_header(args))
		{
			if (indent)
				extra_indent = 1;
			else
			{
				extra_indent = 2;
				printf("\n");
			}
			print_argument_header(args, left_column, indent);
			group = true;
		}
		else if (args->description)
		{
			if (group && args->type != optargs_argument_group_member)
				group = false;
			print_normal_argument(args, left_column, indent + extra_indent);
		}

		if (args->subargument)
		{
			print_all_arguments(args->subargument, left_column, indent + extra_indent + 1);
			group = false;
		}
	}
}

static void
print_usage(char const * NONNULL const exe, struct optargs_option const * NONNULL const opts,
		struct optargs_argument const * NONNULL const args)
{
	assert(exe);

	printf("Usage: %s", exe);

	if (opts && count_printable_options(opts))
		printf(" [OPTIONS]");

	if (args)
		print_arg_names(args);

	printf("\n");
}

void
optargs_print_help(char const * NONNULL const exe, char const * NULLABLE const about,
		struct optargs_option const * NULLABLE const opts,
		struct optargs_argument const * NULLABLE const args)
{
	assert(exe);

	int const left_column = (opts || args) ? find_left_column_maximum(opts, args) : 0;

	print_usage(exe, opts, args);

	if (opts)
		print_all_options(opts, left_column);

	if (args)
		print_all_arguments(args, left_column, 0);

	printf("\n");

	if (about)
		print_wrapped(about, MAX_WIDTH, 0);
}

WARN_UNUSED_RESULT
char const * NONNULL
optargs_option_string(struct optargs_option const * NONNULL const opts)
{
	assert(opts);
	assert(opts->value_type != optargs_flag);

	if (optargs_option_type(opts) != optargs_argument)
	{
		assert(optargs_option_type(opts) == optargs_undef);
		return NULL;
	}

	return optargs_argument_value(opts->argument);
}

WARN_UNUSED_RESULT
unsigned int
optargs_option_count(struct optargs_option const * NONNULL const opts)
{
	assert(opts);
	assert(opts->value_type != optargs_argument);

	if (optargs_option_type(opts) == optargs_undef)
		return 0;

	return opts->count;
}

WARN_UNUSED_RESULT
enum optargs_option_value_type
optargs_option_type(struct optargs_option const * NONNULL const opts)
{
	assert(opts);

	return opts->value_type;
}

WARN_UNUSED_RESULT
char const * NONNULL
optargs_argument_value(struct optargs_argument const * NONNULL a)
{
	assert(a);

	if (!a->result.defined)
		return NULL;

	if (argument_is_header(a))
		return a->result.match->result.value;
	return a->result.value;
}

WARN_UNUSED_RESULT
int
optargs_argument_index(struct optargs_argument const * NONNULL a, int i)
{
	assert(a);
	assert(i >= 0);

	int rv = optargs_argument_offset(&a[i]);

	if (rv < 0)
		return -1;
	else
		return i + rv;
}

WARN_UNUSED_RESULT
int
optargs_argument_offset(struct optargs_argument const * NONNULL a)
{
	assert(a);

	assert(argument_is_header(a));

	if (!a->result.defined)
		return -1;

	return ((long)a->result.match - (long)a)/sizeof(struct optargs_argument);
}

// vim:noet:ts=4:sw=4:ft=c
